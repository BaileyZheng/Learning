# Cache-Based Application Detection in the Cloud Using Machine Learning
## 论文概述
本文提出基于机器学习的技术，从应用的cache访问概要中提取特征，利用这些特征训练机器学习算法模型（支持向量机），然后对应用进行分类，其中特征分析和训练步骤完全是自动完成的。在本地环境下，分类正确率达到98%（L1 cache）和 78%（LLC cache），在Amazon EC2跨虚拟机环境下正确率为60%。


## 笔记
贡献：
- 提出了使用机器学习算法在现代处理器缓存攻击自动化的研究  
为了从缓存访问模式中提取细粒度的信息，对数据进行频繁变换，提取指纹，获取特征。  
为了对一套具有代表性的应用进行分类，使用支持向量机训练模型。  
这就消除了在缓存攻击的制定过程中手动识别模式和制定处理步骤的需要。
- 实现机器学习算法SVM剖析云上其他用户的活动  
- 使用简单的FFT计算从不同类型应用的cache访问数据中提取特征向量  
- 演示了在实现基于SVM的方法时，spy和目标之间不需要同步来剖析应用  
- 如果spy知道目标IP的话，在Amazon EC2上发送ping请求可以获得共驻目标  

共驻检测技术：
- 通过监视L2cache判断攻击者和受害者是否在同一个核上
- 通过分析网络流量检测共驻
- 利用去重检测共驻
- 使用内存总线锁检测共驻  

Cache攻击：
- 广泛用于从支持的加密算法中提取信息  
- 去重可用时：Flush+Reload
- 去重不可用：使用大页+在LLC上使用Prime&Probe

利用缓存切片选择方法：
- 线性切片选择算法：相同的行可以通过改变组号创建排除集 
- 6核切片选择算法：利用不同核上cache的时间差
- 10核

Prime&Probe技术：  
出于安全考虑，现代计算机架构中用户不能看到cache line的物理地址，所以用户可见的是从物理地址转换而来的虚拟地址，虚拟地址和物理地址前12bit完全相同，但是这不足以找到LLC中cache line相应的cache set，所以不能在LLC中庸常规的4KB页创建排出集。  
由于所有的云服务提供者禁用了去重技术，所以Flush+Reload攻击不可行了，所以Prime&Probe技术在云服务上使用最为广泛。为了获得LLC的排出集，spy需要知道物理行的12bit或更多，但是如果spy分配大页（2M），就可以知道cache line的前21bit，这对了解LLC中的相应的set来说足够了。在找到需要的排出集后，eviction就可以实现了。  
Prime&Probe分为三个主要阶段：  
- Prime阶段：创建排出集，spy先生成存放在监视的set中的不同的行，排出集行的数目和监视的set的way数相等，当所有行被spy访问后，排出集就准备好了。  
- Waiting阶段：spy等target从填充的set中挤出一些行，等待的时间对确定分析的分辨率很重要，等待时间越长，频率和分辨率越低。  
- Probe阶段：spy访问填充阶段使用的地址，如果监视集没有被其他进程访问，就没有数据被挤出去，所有的访问结果都命中，访问时间短；如果有其他进程访问了监视集，spy的数据至少被挤出去一行，因此，探测访问将会涉及访问内存，导致可测量的更大的访问时延。  

把机器学习用到cache分析上以检测运行程序，一个特定的用例是检测ping服务，因为ping服务可以用于隐式的共驻测试。  

在cache上提取应用的特征向量：  
程序在cache上有唯一的指纹，使用机器学习算法可以高准确率地学习和分类应用指纹。  
提出的方法首先使用Prime&Probe技术为每个软件创建资料，这样检测应用的动态和静态函数，产生公平可靠的指纹。原始的cache时间跟踪先转换成命中和命失，之后使用傅里叶变换。  
在cache资料上进行傅里叶变换就不需要严格的同步，并且应对噪声更有复原力。  
快速傅里叶变换（FFT）输出可以直接输入到机器学习决策方法。  
L1和LLC分析的方法流图：数据收集 → 转变命中&命失 → FFT → 提取特征 → 机器学习算法  

此方法与先前基于cache信息提取工作的不同：  
- 傅里叶变换  
先前的工作假设监视进程是同步的，同步通过触发事件处理，然后开始分析阶段。当监视进程和target不通信的时候这并不容易，而且应用中周期性地访问的函数可以通过傅里叶变换给出一些信息。因此本文将数据从时域转换成频域，消除了同步这样的强假设，提取周期函数的cache访问作为应用的指纹。  
- 无需去重  
大页+Prime&Probe，结果分析的辨识度比flush+reload低，但是在训练足够的数据后，能有效检测其他共驻虚拟机使用的程序。  
- 检测动态代码  
- Long profiles

```
Fs = FCPU/Tcc  //采样频率
for i from 1 to NS do //每个应用
  for j from 1 to ND do  //每个测试的数据集
    for k from 0 to SL1-1 do  // L1 cache的每个set
      for l from 1 to NT do   //收集的每个轨迹
        if R(i; j; k; l) o then
          R(i; j; k; l) = median(R(i; j; k; 1 : NT))
        end if
        if R(i; j; k; l) c then
          B(i; j; k; l) = 1
        else
          B(i; j; k; l) = 0
        end if
      end for
      L(i; j; k) = F F T [B(i; j; k; 1 : NT)]
    end for
    Lfi,j = L(i; j; 0 : SL-1)
  end for
end for

```

在云上检测ping的步骤：  
- spy vm1 找出嘈杂的set，并将它们从vm1的sl3 set中挤出去
- spy vm2以一定频率发送ping请求  
- spy vm1在剩余set上实现prime&probe
- spy vm1确定llc中活动的set  
- 对活动set使用傅里叶变换  
- 将ping频率和频率成分比较

缓解措施 
- 禁用大页  
由于spy在为Prime&Probe创建排出集的时候需要分配大页，所以VMM禁用大页之后，很难创建排出集，监视其他虚拟机的效率显著下降  
- 私有化LLC分片：  
共驻主机如果在同一个物理机上可以使用整个LLC，所以如果LLC在云上被每个虚拟机分开，profiling阶段就不可能了，但是这对cache架构来说并不现实  
- 对LLC添加噪音：  
通过刷一些cache line避免LLC profiling，即使被监视的应用没有挤出去一个LLC set中的行，spy也会有cache miss，添加噪声会改变hit-miss的频域，机器学习算法成功率会下降  
- 页着色：  
页着色是一个软件技术，管理内存页如何映射到cache line，页着色可以动态地划分LLC，从而限制多租户云中基于cache的侧信道泄露，这样spy虚拟机不能干涉云中其他虚拟机，但是这个方式带来性能开销。
